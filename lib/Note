Flutter GetX----------------------------------------------------------------------------------------
ما همیشه میومدیم برای استفاده از ویجت های متریال از MaterialApp به عنوان روت استفاده میکردیم
حالا میایم از GetMaterialApp استفاده میکنیم که مال لایبرری گت ایکس هستش
در اصل یک ویجت هست که متریال اپ اصلی فرزندشه

SnackBar--------------------------------------------------------------------------------------------
titleText
messageText
این دو تا میتونن به جای تکست ساده ویجت بگیرن
و اولویت این دو تا اتریبیوت از تایتل و مسیج دیفالت بالاتره

colorText
backgroundColor
این دو تا روی تایتل و مسیج دیفالتش ست میشه

borderWidth
borderColor
حتما برای دیده شدن رنگ بردر باید قبلش ویت بدید بهش

animationDuration
مدت زمان اجرای انیمیشن
duration
مدت زمانی که اسنک بار روی صفحه می ماند

overlayBlur :
صفحه پشت رو بلور میکنه

forwardAnimationCurve
reverseAnimationCurve
یکیش انیمیشن ورود هست یکی خروج

snackbarStatus :
SnackbarStatus.OPENING
SnackbarStatus.CLOSING
SnackbarStatus.CLOSED
SnackbarStatus.OPENING
SnackbarStatus.OPEN
SnackbarStatus.CLOSING
SnackbarStatus.CLOSED

Dialog----------------------------------------------------------------------------------------------
middleText vs Content
کانتنت کاستومایز شده میدل تکست هست

Reactive State Management---------------------------------------------------------------------------
If we want that every time the value of variable changes
then all the widgets which uses variable must update itself
then the variable must be reactive or observable
================================================
1-
and to make reactive (Rx) .obs is used with variable value
var count = 0.obs ;
To update the widget which uses Rx :
variable must be placed inside
obx(()=> your widget which uses rx)
The widget will update if and only if the rx variable value changes

Other ways of making variable rx:
===============================================
2- The first is using Rx (Type)
Initial value is recommended, but not mandatory
final name = RxString('') ;
final isLogged = RxBool(false) ;
final count = RxInt(0);
final balance = RxDouble(0.0);
final items = RxList<String>([]);
final myMap = RxMap<String, int>({});

==============================================
3- Use Darts Generics, Rx<Type>
final name = Rx<String>('');
final count = Rx<Bool>(false);
final count = Rx<Int>(0);
final balance = Rx<Double>(0.0);
final number = Rx<Num>(0);
final items = Rx<List<String>>([]);
final myMap = Rx<Map<String, int>>({});

//Custom classes - it can be any class, literally
final user = Rx<User>();

Reactive State Manager Using Obx and User Defined class---------------------------------------------
Classes can be made observable by making individuals variables Rx
or by making the entire class observable

class Student{
  var name = "Tom".obs() ;
  var age = 25.obs() ;
}

To make the entire class observable
var name ;
var age ;
Student({this.name , this.age});
.
.
.
final student = Student(name:"Tom" , age:25).obs ;

Bug?-------------------------------------------
به دلیل نامشخصی وقتی با .obs تعریف میکنیم متغیر رو
خیلی وقتا تو آپدیت کردن value به مشکل میخوره مخصوصا داخل کلاس
var name = RxString('poop');
خیلی روش بهتریه و اون مشکل رو نداره

====================================================
To update the widget which uses Rx :

1- if individual variable is observable :
student.name = student.name.toUpperCase() ;

2- if entire class is observable  :
 student2.update((val) {
     val!.name = val.name.toUpperCase() ;
                       });

GetX Controller-------------------------------------------------------------------------------------
توی بخش قبلی کد مربوط به UI & business logic روی توی یک فایل مینوشتیم که کار اصولی ای نیست
توی این بخش یاد میگیریم چطور این دو بخش رو از هم جدا کنیم با استفاده از کنتترلر گت ایکس

1-
به این منظور یک کلاس میسازیم که از GetxController ارث بری می کند
class MyController extends GetxController
 و عملیاتمون رو داخل این کلاس انجام میدیم
 یعنی هر آنچه قبلا توی onTap مینوشتیم حالا اینجا مینویسیم

2-
برای دسترسی به کنترلر از UI از کد زیر استفاده میکنیم
 MyController myController = Get.put(MyController()) ;

GetX<ControllerType>--------------------------------------------------------------------------------
If init property is not used in GetX<TypeOfController>
then create the instance of controller as follow
MyController myController = Get.put(MyController()) ;

حالا اگه بخوایم از روش دوم استفاده کنیم
1-
به جای obx باید از روش زیر استفاده کنیم
  GetX<MyController>(
 init: myController,
 builder: (controller) =>
 Text('controller2 value is ${controller.count}') )

 توی init میاد initialize میکنه اون کنترلر رو
 و توی builder میاد یک instance از کنترلر  رو برمیگردونه

 2-
 برای صدا زدن متد به جای روش زیر
myController.convertToUpperCase() ;
از این روش استفاده میکنیم
Get.find<MyController>().increment() ;
با استفاده از کد بالا instance ي که از کنترلر ساختیم رو دریافت میکنیم

نکته:
اگر از اون init استفاده نکنیم باید به روش
MyController myController = Get.put(MyController()) ;
مقداردهی کنیم کنترلر رو
Get.find<MyController>().increment() ;
و اینجوری استفاده کنیم

GetBuilder<ControllerType>--------------------------------------------------------------------------
توی این دو تا روشی که از اتریبیوت init استفاده کردیم
چون init اجباری نیست
میشه استفاده ش نکرد و به روش
MyController myController = Get.put(MyController()) ;
ساخت و دسترسی داشت به کنترلر

Controller LifeCycle--------------------------------------------------------------------------------
برای کار روی لایف سایکل کنترلر رو روش هست

روش اول
استفاده از این دو تا اتریبیوت توی بیلدر
initState: (state) => myController.incrementNumberEvery5Seconds(),
dispose: (state) => myController.cleanUpTask(),

روش دوم و اصولی تر:
اورراید کردن همین دو تا توی خود کنترلر